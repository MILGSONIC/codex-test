<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Crab Juggling Animation</title>
<style>
  body {
    margin: 0;
    background: #f0f0f0;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: none; /* background drawn via canvas */
  }
</style>
</head>
<body>
<canvas id="crabCanvas" width="800" height="600"></canvas>
<script>
const canvas = document.getElementById('crabCanvas');
const ctx = canvas.getContext('2d');
const centerX = canvas.width / 2;
// vertical level where the claw tips sit
const clawBaseY = canvas.height - 160;
const ballRadius = 20;
// horizontal and vertical amplitude for juggling path
// horizontal amplitude adjusted so balls reach the claws
const amplitudeX = 120;
const amplitudeY = 120;


const balls = [
  { phase: -Math.PI / 2, radius: 20, color: '#FFFFFF', shape: 'soccer' },
  { phase: Math.PI / 2, radius: 22, color: '#FFFFFF', shape: 'soccer' }
];

// bubble configuration
const sandHeight = 60;
const bubbles = Array.from({ length: 15 }, () => ({
  x: Math.random() * canvas.width,
  y: canvas.height - sandHeight - Math.random() * 100,
  radius: 2 + Math.random() * 3,
  speed: 0.5 + Math.random()
}));


function drawCrab(time) {
  const bodyX = centerX;
  const bodyY = canvas.height - 80;
  const bodyWidth = 80;
  const bodyHeight = 40;

  // body with radial gradient for a rounded look
  const bodyGradient = ctx.createRadialGradient(
    bodyX,
    bodyY - bodyHeight * 0.3,
    bodyHeight * 0.3,
    bodyX,
    bodyY,
    bodyWidth
  );
  bodyGradient.addColorStop(0, '#66aaff'); // lighter center
  bodyGradient.addColorStop(1, '#000080'); // darker edges
  ctx.fillStyle = bodyGradient;
  ctx.beginPath();
  ctx.ellipse(bodyX, bodyY, bodyWidth, bodyHeight, 0, 0, Math.PI * 2);
  ctx.fill();

  // legs with subtle animation
  ctx.strokeStyle = '#000080';
  ctx.lineWidth = 4;
  for (let i = -3; i <= 3; i++) {
    if (i === 0) continue;
    const direction = Math.sign(i);
    const baseX = bodyX + i * 15;
    const baseY = bodyY + bodyHeight;
    drawLeg(baseX, baseY, direction, i, time);
  }

  // claws animation
  const clawAngle = Math.sin(time / 500) * 0.5;
  drawClaw(bodyX - bodyWidth, bodyY - 10, -1, clawAngle);
  drawClaw(bodyX + bodyWidth, bodyY - 10, 1, -clawAngle);

  // eyes
  const eyeOffsetX = 20;
  const eyeOffsetY = 25;
  drawEye(bodyX - eyeOffsetX, bodyY - eyeOffsetY);
  drawEye(bodyX + eyeOffsetX, bodyY - eyeOffsetY);
}

function drawClaw(x, y, direction, angle) {
  ctx.save();
  ctx.translate(x, y);
  ctx.strokeStyle = '#000080';
  ctx.fillStyle = '#66aaff';
  ctx.lineWidth = 6;

  // arm extending outward from the body
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(40 * direction, 0);
  ctx.stroke();

  // move to end of arm and rotate claw upward
  ctx.translate(40 * direction, 0);
  ctx.rotate(-direction * Math.PI / 2 + angle);

  // rounded base of the claw
  ctx.beginPath();
  ctx.ellipse(20 * direction, -10, 20, 15, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  // upper pincer
  ctx.beginPath();
  ctx.moveTo(35 * direction, -15);
  ctx.quadraticCurveTo(55 * direction, -30, 70 * direction, -5);
  ctx.stroke();

  // lower pincer as an oval segment
  ctx.beginPath();
  ctx.ellipse(55 * direction, -2, 20, 10, 0, 0, Math.PI, true);
  ctx.stroke();

  ctx.restore();
}

function drawLeg(x, y, direction, index, time) {
  ctx.beginPath();
  ctx.moveTo(x, y);
  const oscillation = Math.sin(time / 400 + index) * 5;
  ctx.lineTo(x + 10 * direction, y + 15 + oscillation);
  ctx.lineTo(x + 20 * direction, y + 30 + oscillation);
  ctx.lineTo(x + 25 * direction, y + 45);
  ctx.stroke();
}

function drawEye(x, y) {
  ctx.fillStyle = 'white';
  ctx.beginPath();
  ctx.arc(x, y, 8, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'black';
  ctx.beginPath();
  ctx.arc(x, y, 3, 0, Math.PI * 2);
  ctx.fill();
}

function drawStar(radius, color) {
  const inner = radius * 0.5;
  ctx.fillStyle = color;
  ctx.beginPath();
  for (let i = 0; i < 5; i++) {
    const outerAngle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
    const innerAngle = outerAngle + Math.PI / 5;
    if (i === 0) {
      ctx.moveTo(Math.cos(outerAngle) * radius, Math.sin(outerAngle) * radius);
    } else {
      ctx.lineTo(Math.cos(outerAngle) * radius, Math.sin(outerAngle) * radius);
    }
    ctx.lineTo(Math.cos(innerAngle) * inner, Math.sin(innerAngle) * inner);
  }
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawSoccerBall(radius) {
  ctx.fillStyle = 'white';
  ctx.beginPath();
  ctx.arc(0, 0, radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.fillStyle = 'black';
  for (let i = 0; i < 6; i++) {
    const angle = i * Math.PI / 3;
    const x = Math.cos(angle) * radius * 0.5;
    const y = Math.sin(angle) * radius * 0.5;
    ctx.beginPath();
    ctx.arc(x, y, radius * 0.25, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawBall(x, y, time, opts = {}) {
  const radius = opts.radius || ballRadius;
  const color = opts.color || 'white';
  const shape = opts.shape || 'ball';

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(time / 500);

  if (shape === 'star') {
    drawStar(radius, color);
  } else if (shape === 'soccer') {
    drawSoccerBall(radius);
  } else {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  ctx.restore();
}

function drawBubbles() {
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  bubbles.forEach(b => {
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
    ctx.fill();
    b.y -= b.speed;
    if (b.y + b.radius < 0) {
      b.y = canvas.height - sandHeight;
      b.x = Math.random() * canvas.width;
    }
  });
}

function drawLoadingText(time) {
  ctx.font = 'bold 32px sans-serif';
  ctx.fillStyle = '#000080';
  ctx.textAlign = 'center';
  const dots = Math.floor(time / 500) % 4;
  ctx.fillText('Loading' + '.'.repeat(dots), centerX, 60);
}

function animate(time) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // sky/water background
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, '#87CEEB');
  gradient.addColorStop(0.7, '#E0FFFF');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // seabed
  ctx.fillStyle = '#F4A460';
  ctx.fillRect(0, canvas.height - sandHeight, canvas.width, sandHeight);

  drawBubbles();

  drawCrab(time);
  drawLoadingText(time);

  balls.forEach(ball => {
    const angle = time / 600 + ball.phase;
    const x = centerX + amplitudeX * Math.sin(angle);
    const y = clawBaseY - Math.abs(Math.cos(angle)) * amplitudeY;
    drawBall(x, y, time + ball.phase * 100, ball);
  });

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
</script>
</body>
</html>

